import sys
import uuid
import math
from PyQt5.QtWidgets import QApplication, QWidget, QGridLayout, QLineEdit, QPushButton, QLabel, QGroupBox, QVBoxLayout

class TextDisplayApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BGA Alignment Dimensions")
        self.layout = QGridLayout()

        # X-Axis Column
        x_group = QGroupBox("X-Axis")
        x_layout = QVBoxLayout()
        self.x_pads_entry = QLineEdit(self)
        self.x_pads_entry.setPlaceholderText("Number of Pads (X)")
        x_layout.addWidget(self.x_pads_entry)
        self.pitch_x_entry = QLineEdit(self)
        self.pitch_x_entry.setPlaceholderText("Pitch (X-Axis) [mm]")
        x_layout.addWidget(self.pitch_x_entry)
        self.package_dim_x = QLineEdit(self)
        self.package_dim_x.setPlaceholderText("Package Dimension (X-Axis) [mm]")
        x_layout.addWidget(self.package_dim_x)
        self.optical_offset_x = QLineEdit(self)
        self.optical_offset_x.setPlaceholderText("Optical Offset (X-Axis) [µm]")
        x_layout.addWidget(self.optical_offset_x)
        self.inner_optical_frame_x = QLineEdit(self)
        self.inner_optical_frame_x.setPlaceholderText("Inner Optical Frame [mm]")
        x_layout.addWidget(self.inner_optical_frame_x)
        self.outer_optical_frame_x = QLineEdit(self)
        self.outer_optical_frame_x.setPlaceholderText("Outer Optical Frame [mm]")
        x_layout.addWidget(self.outer_optical_frame_x)        
        self.MH_x = QLineEdit(self)
        self.MH_x.setPlaceholderText("Mounting Hole Distance [mm]")
        x_layout.addWidget(self.MH_x)       
        x_group.setLayout(x_layout)

        # Y-Axis Column
        y_group = QGroupBox("Y-Axis")
        y_layout = QVBoxLayout()
        self.y_pads_entry = QLineEdit(self)
        self.y_pads_entry.setPlaceholderText("Number of Pads (Y)")
        y_layout.addWidget(self.y_pads_entry)
        self.pitch_y_entry = QLineEdit(self)
        self.pitch_y_entry.setPlaceholderText("Pitch (Y-Axis) [mm]")
        y_layout.addWidget(self.pitch_y_entry)
        self.package_dim_y = QLineEdit(self)
        self.package_dim_y.setPlaceholderText("Package Dimension (Y-Axis) [mm]")
        y_layout.addWidget(self.package_dim_y)
        self.optical_offset_y = QLineEdit(self)
        self.optical_offset_y.setPlaceholderText("Optical Offset (Y-Axis) [µm]")
        y_layout.addWidget(self.optical_offset_y)
        self.inner_optical_frame_y = QLineEdit(self)
        self.inner_optical_frame_y.setPlaceholderText("Inner Optical Frame [mm]")
        y_layout.addWidget(self.inner_optical_frame_y)
        self.outer_optical_frame_y = QLineEdit(self)
        self.outer_optical_frame_y.setPlaceholderText("Outer Optical Frame [mm]")
        y_layout.addWidget(self.outer_optical_frame_y)    
        self.MH_y = QLineEdit(self)
        self.MH_y.setPlaceholderText("Mounting Hole Distance [mm]")
        y_layout.addWidget(self.MH_y)
        y_group.setLayout(y_layout)

        # General Information Row
        info_group = QGroupBox("General Information")
        info_layout = QVBoxLayout()
        self.BGA_diameter = QLineEdit(self)
        self.BGA_diameter.setPlaceholderText("BGA Diameter [mm]")
        info_layout.addWidget(self.BGA_diameter)
        self.MH_Size = QLineEdit(self)
        self.MH_Size.setPlaceholderText("Mounting Hole Size [mm]")
        info_layout.addWidget(self.MH_Size)
        self.MH_Drill = QLineEdit(self)
        self.MH_Drill.setPlaceholderText("Mounting Hole Drill [mm]")
        info_layout.addWidget(self.MH_Drill)
        info_group.setLayout(info_layout)
        self.layout.addWidget(info_group, 1, 0, 1, 2)
        

        # Add groups
        self.layout.addWidget(x_group, 0, 0)
        self.layout.addWidget(y_group, 0, 1)

        # Save button
        self.save_button = QPushButton("Save Inputs + Generate Footprint")
        self.save_button.clicked.connect(self.save_inputs)
        self.layout.addWidget(self.save_button, 2, 0, 1, 2)

        self.setLayout(self.layout)

    def get_row_labels(self, num_rows):
        """Return row labels A, B, ... Z, AA, AB, ... for num_rows."""
        labels = []
        for i in range(num_rows):
            label = ""
            n = i
            while True:
                n, remainder = divmod(n, 26)
                label = chr(65 + remainder) + label
                if n == 0:
                    break
                n -= 1
            labels.append(label)
        return labels

    def make_kicad_footprint(self, data, row_labels, bga_start_x, bga_start_y, optical_offset_x_mm, optical_offset_y_mm):
        """Generate the full KiCad .kicad_mod footprint text."""
        try:
            footprint = []
            footprint.append(f'(module "BGA_Footprint" (layer "F.Cu") (tedit {uuid.uuid4().hex[:8]})')

            # reference + value
            ref_y = (data["package_dim_y"]/2) + 1
            val_y = (data["package_dim_y"]/-2) - 1
            footprint.append(f'  (fp_text reference "REF**" (at 0 {ref_y:.4f}) (layer "F.SilkS"))')
            footprint.append(f'  (fp_text value "BGA_Footprint" (at 0 {val_y:.4f}) (layer "F.Fab"))')
            
            # Package Boundaries Fabrication and Courtyards
            half_x = data["package_dim_x"] / 2
            half_y = data["package_dim_y"] / 2
            court_x = data["package_dim_x"] / 2 + 0.1
            court_y = data["package_dim_y"] / 2 + 0.1
            
            package_fab = f'''  (fp_rect (start {-half_x:.4f} {-half_y:.4f}) (end {half_x:.4f} {half_y:.4f}) 
        (stroke (width 0.10) (type solid)) (layer "F.Fab") (fill no) (uuid "{uuid.uuid4()}")
    )'''
            footprint.append(package_fab)
            
            package_courtyard = f'''  (fp_rect (start {-court_x:.4f} {-court_y:.4f}) (end {court_x:.4f} {court_y:.4f}) 
        (stroke (width 0.10) (type solid)) (layer "F.CrtYd") (fill no) (uuid "{uuid.uuid4()}")
    )'''
            footprint.append(package_courtyard)

            # Optical Frame Rectangles 
            inner_half_x = (data["inner_optical_frame_x"] / 2) + optical_offset_x_mm
            inner_half_y = (data["inner_optical_frame_y"] / 2) + optical_offset_y_mm
            outer_half_x = (data["outer_optical_frame_x"] / 2) + optical_offset_x_mm
            outer_half_y = (data["outer_optical_frame_y"] / 2) + optical_offset_y_mm

            inner_end_x = inner_half_x + 2 * (-optical_offset_x_mm)
            inner_end_y = inner_half_y + 2 * -optical_offset_y_mm
            outer_end_x = outer_half_x + 2 * (-optical_offset_x_mm)
            outer_end_y = outer_half_y + 2 * -optical_offset_y_mm

            inner_frame = f'''  (fp_rect (start {-inner_half_x:.4f} {-inner_half_y:.4f}) (end {inner_end_x:.4f} {inner_end_y:.4f})
        (stroke (width 0.10) (type solid)) (layer "F.SilkS") (fill no) (uuid "{uuid.uuid4()}")
    )'''
            outer_frame = f'''  (fp_rect (start {-outer_half_x:.4f} {-outer_half_y:.4f}) (end {outer_end_x:.4f} {outer_end_y:.4f})
        (stroke (width 0.10) (type solid)) (layer "F.SilkS") (fill no) (uuid "{uuid.uuid4()}")
    )'''
            footprint.append(inner_frame)
            footprint.append(outer_frame)

            # Keep out Zone For Optical Frame 
            keepouts = []

            # Top strip
            keepouts.append(f'''  (zone
        (net 0)
        (net_name "")
        (layer "F.Cu")
        (uuid "{uuid.uuid4()}")
        (hatch edge 0.5)
        (connect_pads (clearance 0))
        (min_thickness 0.25)
        (filled_areas_thickness no)
        (keepout (tracks allowed) (vias allowed) (pads not_allowed) (copperpour allowed) (footprints not_allowed))
        (fill (thermal_gap 0.5) (thermal_bridge_width 0.5))
        (polygon
        (pts
            (xy {-outer_half_x:.4f} {inner_end_y:.4f})
            (xy {outer_end_x:.4f} {inner_end_y:.4f})
            (xy {outer_end_x:.4f} {outer_end_y:.4f})
            (xy {-outer_half_x:.4f} {outer_end_y:.4f})
        )
        )
    )''')
            
            # Bottom strip
            keepouts.append(f'''  (zone
        (net 0)
        (net_name "")
        (layer "F.Cu")
        (uuid "{uuid.uuid4()}")
        (hatch edge 0.5)
        (connect_pads (clearance 0))
        (min_thickness 0.25)
        (filled_areas_thickness no)
        (keepout (tracks allowed) (vias allowed) (pads not_allowed) (copperpour allowed) (footprints not_allowed))
        (fill (thermal_gap 0.5) (thermal_bridge_width 0.5))
        (polygon
        (pts
            (xy {-outer_half_x:.4f} {-outer_half_y:.4f})
            (xy {outer_end_x:.4f} {-outer_half_y:.4f})
            (xy {outer_end_x:.4f} {-inner_half_y:.4f})
            (xy {-outer_half_x:.4f} {-inner_half_y:.4f})
        )
        )
    )''')
            
            # Left strip
            keepouts.append(f'''  (zone
        (net 0)
        (net_name "")
        (layer "F.Cu")
        (uuid "{uuid.uuid4()}")
        (hatch edge 0.5)
        (connect_pads (clearance 0))
        (min_thickness 0.25)
        (filled_areas_thickness no)
        (keepout (tracks allowed) (vias allowed) (pads not_allowed) (copperpour allowed) (footprints not_allowed))
        (fill (thermal_gap 0.5) (thermal_bridge_width 0.5))
        (polygon
        (pts
            (xy {-outer_half_x:.4f} {-inner_half_y:.4f})
            (xy {-inner_half_x:.4f} {-inner_half_y:.4f})
            (xy {-inner_half_x:.4f} {inner_end_y:.4f})
            (xy {-outer_half_x:.4f} {inner_end_y:.4f})
        )
        )
    )''')
            
            # Right strip
            keepouts.append(f'''  (zone
        (net 0)
        (net_name "")
        (layer "F.Cu")
        (uuid "{uuid.uuid4()}")
        (hatch edge 0.5)
        (connect_pads (clearance 0))
        (min_thickness 0.25)
        (filled_areas_thickness no)
        (keepout (tracks allowed) (vias allowed) (pads not_allowed) (copperpour allowed) (footprints not_allowed))
        (fill (thermal_gap 0.5) (thermal_bridge_width 0.5))
        (polygon
        (pts
            (xy {inner_end_x:.4f} {-inner_half_y:.4f})
            (xy {outer_end_x:.4f} {-inner_half_y:.4f})
            (xy {outer_end_x:.4f} {inner_end_y:.4f})
            (xy {inner_end_x:.4f} {inner_end_y:.4f})
        )
        )
    )''')
            
            # Append all 4 keepout strips
            footprint.extend(keepouts)

            # --- Mounting Holes (Placement and Keepout Zones) ---
            MH = []

            # Left MH
            mh_left_x = -(data["MH_x"]/2 + optical_offset_x_mm)
            mh_left_y = -(data["MH_y"] + optical_offset_y_mm)
            MH.append(f'''  (pad "MH1" thru_hole circle
            (at {mh_left_x:.4f} {mh_left_y:.4f})
            (size {data["MH_Size"]:.4f} {data["MH_Size"]:.4f})
            (drill {data["MH_Drill"]:.4f})
            (layers "*.Cu" "*.Mask")
            (remove_unused_layers no)
            (uuid "{uuid.uuid4()}")
        )''')

            # Right MH
            mh_right_x = (data["MH_x"]/2 - optical_offset_x_mm)
            mh_right_y = -(data["MH_y"] + optical_offset_y_mm)
            MH.append(f'''  (pad "MH2" thru_hole circle
            (at {mh_right_x:.4f} {mh_right_y:.4f})
            (size {data["MH_Size"]:.4f} {data["MH_Size"]:.4f})
            (drill {data["MH_Drill"]:.4f})
            (layers "*.Cu" "*.Mask")
            (remove_unused_layers no)
            (uuid "{uuid.uuid4()}")
        )''')

            footprint.extend(MH)

            # --- Define Mounting Hole Centers ---
            center_x_L = mh_left_x
            center_y_L = mh_left_y
            center_x_R = mh_right_x
            center_y_R = mh_right_y

            def generate_arc(center_x, center_y, radius, outer_half_x, optical_offset_y_mm, layer, location="L"):
                """
                Generates a KiCad fp_arc with start and end points + angle.
                Falls back to a full fp_circle if no intersection is found.
                """
                try:
                    # --- Find intersection of circle and vertical line ---
                    def find_intersection(cx, cy, r, x_line):
                        dx = x_line - cx
                        if abs(dx) > r:
                            return None  # No intersection
                        dy = math.sqrt(r**2 - dx**2)
                        y1 = cy + dy
                        y2 = cy - dy
                        return (x_line, y1), (x_line, y2)

                    if location == "L":
                        intersections = find_intersection(center_x, center_y, radius, -outer_half_x)
                    elif location == "R":
                        intersections = find_intersection(center_x, center_y, radius, outer_half_x)
                    else:
                        raise ValueError("location must be 'L' or 'R'")

                    if intersections is None:
                        # --- Fallback: full circle ---
                        return f'''  (fp_circle
                (center {center_x:.6f} {center_y:.6f})
                (end {center_x + radius:.6f} {center_y:.6f})
                (stroke (width 0.10) (type default))
                (fill no)
                (layer "{layer}")
                (uuid "{uuid.uuid4()}")
            )'''

                    (x1, y1), (x2, y2) = intersections

                    # Choose the intersection point for the arc start
                    start_x, start_y = (x1, y1) if location == "L" else (x2, y2)

                    # Determine the angle of start point relative to center
                    angle_rad = math.atan2(start_y - center_y, start_x - center_x)
                    angle_deg = math.degrees(angle_rad)
                    if location == "L":
                        angle_span = 360 - (2 * abs(angle_deg))
                    elif location == "R":
                        angle_span = 2 * abs(angle_deg)

                    # --- Return KiCad arc ---
                    return f'''  (fp_arc
                (start {center_x:.6f} {center_y:.6f}) 
                (end {start_x:.6f} {start_y - optical_offset_y_mm:.6f}) 
                (angle {angle_span:.6f})
                (stroke (width 0.10) (type default))
                (layer "{layer}")
                (uuid "{uuid.uuid4()}")
            )'''
                except Exception as e:
                    # Last resort fallback: circle
                    return f'''  (fp_circle
                (center {center_x:.6f} {center_y:.6f})
                (end {center_x + radius:.6f} {center_y:.6f})
                (stroke (width 0.10) (type default))
                (fill no)
                (layer "{layer}")
                (uuid "{uuid.uuid4()}")
            )'''


            # --- Mounting Hole Silkscreen + Fab ---
            MH_silk_fab = []

            # Add left MH circles + arcs
            for offset in [0.15, 0.58]:
                MH_silk_fab.append(f'''  (fp_circle
            (center {center_x_L:.4f} {center_y_L:.4f})
            (end {center_x_L + (data["MH_Size"]/2 + offset):.4f} {center_y_L:.4f})
            (stroke (width 0.10) (type default))
            (fill no)
            (layer "F.Fab")
            (uuid "{uuid.uuid4()}")
        )''')
                arc = generate_arc(center_x_L, center_y_L, data["MH_Size"]/2 + offset, outer_half_x, optical_offset_y_mm, "F.SilkS", "L")
                if arc:
                    MH_silk_fab.append(arc)

            # Add right MH circles + arcs
            for offset in [0.15, 0.58]:
                MH_silk_fab.append(f'''  (fp_circle
            (center {center_x_R:.4f} {center_y_R:.4f})
            (end {center_x_R + (data["MH_Size"]/2 + offset):.4f} {center_y_R:.4f})
            (stroke (width 0.10) (type default))
            (fill no)
            (layer "F.Fab")
            (uuid "{uuid.uuid4()}")
        )''')
                arc = generate_arc(center_x_R, center_y_R, data["MH_Size"]/2 + offset, outer_end_x, optical_offset_y_mm, "F.SilkS", "R")
                if arc:
                    MH_silk_fab.append(arc)

            footprint.extend(MH_silk_fab)

            # Add keepout zones for MH
            def generate_keepout_zone(center_x, center_y, inner_r, outer_r, num_points=64):
                """
                Generate a KiCad keepout zone polygon between inner_r and outer_r.
                """
                pts = []

                # Outer circle (counter-clockwise)
                for i in range(num_points):
                    theta = 2 * math.pi * i / num_points
                    x = center_x + outer_r * math.cos(theta)
                    y = center_y + outer_r * math.sin(theta)
                    pts.append(f'(xy {x:.6f} {y:.6f})')

                # Inner circle (clockwise)
                for i in reversed(range(num_points)):
                    theta = 2 * math.pi * i / num_points
                    x = center_x + inner_r * math.cos(theta)
                    y = center_y + inner_r * math.sin(theta)
                    pts.append(f'(xy {x:.6f} {y:.6f})')

                # Wrap into zone
                zone = f'''  (zone
                (net 0)
                (net_name "")
                (layer "F.Cu")
                (uuid "{uuid.uuid4()}")
                (hatch edge 0.5)
                (connect_pads (clearance 0))
                (min_thickness 0.25)
                (filled_areas_thickness no)
                (keepout
                (tracks allowed)
                (vias allowed)
                (pads not_allowed)
                (copperpour allowed)
                (footprints not_allowed)
                )
                (polygon
                (pts
                    {' '.join(pts)}
                )
                )
            )'''
                return zone
            inner_offset = 0.15
            outer_offset = 0.58

            # Left MH zone
            keepout_L = generate_keepout_zone(center_x_L, center_y_L,
                                            data["MH_Size"]/2 + inner_offset,
                                            data["MH_Size"]/2 + outer_offset)
            footprint.append(keepout_L)

            # Right MH zone
            keepout_R = generate_keepout_zone(center_x_R, center_y_R,
                                            data["MH_Size"]/2 + inner_offset,
                                            data["MH_Size"]/2 + outer_offset)
            footprint.append(keepout_R)


            # pad generation
            for j in range(data["y_pads"]):   # loop rows (letters)
                row_label = row_labels[j]
                for i in range(data["x_pads"]):   # loop columns (numbers)
                    col_number = i + 1
                    pad_x = bga_start_x + i * data["pitch_x"]
                    pad_y = -(bga_start_y + j * data["pitch_y"])
                    pad_name = f"{row_label}{col_number}"
                    pad_uuid = str(uuid.uuid4())

                    pad_block = f'''  (pad "{pad_name}" smd circle
    (at {pad_x:.4f} {pad_y:.4f})
    (size {data["pad_size"]:.2f} {data["pad_size"]:.2f})
    (layers "F.Cu" "F.Paste" "F.Mask")
    (uuid "{pad_uuid}")
  )'''
                    footprint.append(pad_block)

            footprint.append(")")  # end module
            return "\n".join(footprint)
            
        except Exception as e:
            print(f"Error in make_kicad_footprint: {e}")
            raise

    def save_inputs(self):
        """Read user inputs, print coordinates, and generate footprint file."""
        try:
            # Read inputs with proper error handling
            def get_float_value(widget, default_value):
                text = widget.text().strip()
                if not text:
                    return default_value
                return float(text)
                
            def get_int_value(widget, default_value):
                text = widget.text().strip()
                if not text:
                    return default_value
                return int(text)

            data = {
                "x_pads": get_int_value(self.x_pads_entry, 11),
                "package_dim_x": get_float_value(self.package_dim_x, 8.7555),
                "pitch_x": get_float_value(self.pitch_x_entry, 0.7),
                "optical_offset_x": get_float_value(self.optical_offset_x, -107.8988),
                "inner_optical_frame_x": get_float_value(self.inner_optical_frame_x, 14),
                "outer_optical_frame_x": get_float_value(self.outer_optical_frame_x, 16.5),
                "MH_x": get_float_value(self.MH_x, 20.0),

                "y_pads": get_int_value(self.y_pads_entry, 7),
                "package_dim_y": get_float_value(self.package_dim_y, 5.5118),
                "pitch_y": get_float_value(self.pitch_y_entry, 0.6),
                "optical_offset_y": get_float_value(self.optical_offset_y, -11.1802),
                "inner_optical_frame_y": get_float_value(self.inner_optical_frame_y, 14),
                "outer_optical_frame_y": get_float_value(self.outer_optical_frame_y, 16.5),
                "MH_y": get_float_value(self.MH_y, 0.0),

                # default pad size (you can expose this in GUI later)
                "pad_size": get_float_value(self.BGA_diameter, 0.25),
                "MH_Size": get_float_value(self.MH_Size, 3.216),
                "MH_Drill": get_float_value(self.MH_Drill, 2.2),
            }

            # Convert offsets to mm
            optical_offset_x_mm = data["optical_offset_x"] / 1000.0
            optical_offset_y_mm = data["optical_offset_y"] / 1000.0

            # Compute starting corner
            bga_start_x = (data["x_pads"] - 1) / -2 * data["pitch_x"] - optical_offset_x_mm
            bga_start_y = (data["y_pads"] - 1) / -2 * data["pitch_y"] + optical_offset_y_mm

            # Generate row labels (reverse order)
            row_labels = self.get_row_labels(data["y_pads"])[::-1]

            print("BGA Pad Coordinates (in mm):")
            for j in range(data["y_pads"]):   # loop rows (letters)
                row_label = row_labels[j]
                for i in range(data["x_pads"]):   # loop columns (numbers)
                    col_number = i + 1
                    pad_x = bga_start_x + i * data["pitch_x"]
                    pad_y = -(bga_start_y + j * data["pitch_y"])
                    print(f"{row_label}{col_number}: ({pad_x:.3f}, {pad_y:.3f}) mm")

            # Generate KiCad footprint file
            footprint_text = self.make_kicad_footprint(data, row_labels, bga_start_x, bga_start_y, optical_offset_x_mm, optical_offset_y_mm)
            
            with open("BGA_Footprint.kicad_mod", "w") as f:
                f.write(footprint_text)

            print("✅ KiCad footprint saved as BGA_Footprint.kicad_mod")
            print("User Inputs:", data)

        except ValueError as e:
            print(f"⚠️ Invalid input detected: {e}")
            print("Please enter valid numbers only.")
        except Exception as e:
            print(f"⚠️ Error occurred: {e}")
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = TextDisplayApp()
    window.resize(600, 400)
    window.show()
    sys.exit(app.exec_())
